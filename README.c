一：开发过的几个特殊的串口。
1. 230 ：顺序可设的串口协议的典范。
2. 500 ：一个比较特殊的下发多个实时采样的命令，命令见间相互有依赖。
2. 950 ：一个可以实现在串口程序中向模拟量程序发送控制的命令的串口程序。
3. 955 ：一个整形16进制数，和附浮点16进制数的解析。
4. 941 ：解析的数据比较复杂。
5. Test_695 : 是一个比较特殊的串口程序，它是将一串字符串分别转化为一串相同的16进制数，然后根据这传16进制数，等到相应的值(浮点型).
6. 998 ：串口协议中实现配置文件的解析，如果有使用配置文件的可以参考。
7. 997 ：此串口协议中前端设备回复的是一个double型号的数据(由8个字节组成的)，里面是解析的方式。    

二：几个拆解字符串的方法。
1. 如果想要将4字节16进制的数据转化为浮点型数据，可以借助联合体。
如果是4个字节整型的16进制数， 联合的定义可为:
union{
	int value;
	char buf[4];
}
而如果是4个字节浮点型的16进制数，联合体的定义变成:
union{
	float value;
	char buf[4];
}

2. 如果想要将一串字符串转化为16进制的长整型数可用strol函数。

3. 将一串字符串中特殊的数据获出来， 如想把 “adb12.6defrtd(33.6)gh”中的33.6给获取出来，代码如下：
#include <stdio.h>
int main(int argc, const char *argv[])
{
	float rtd = 0;
	char rx_buf[32] = {0};

	sprintf(rx_buf, "abc12.6efrtd(33.6)gh");

	sscanf(rx_buf, "%*[^(](%f", &rtd);
	printf("rtd = %f\n", rtd);
	return 0;
}

4. 想把ASCII码转化为相同的16进制数的方法如下(ASCII:01 02 03 04 转化为HEX：0x01 0x02 0x03 0x04)
	解决的方法是利用strtol函数将每一个字符串(如01 转化为0x01)转化为相应的16进制数，然后再将这一串经过转化好的
	16进制字符串放入一个联合体中，这样就可有获取到，想要的数据。(具体方法可以参考695完全版串口程序 或者是1044串口协议)

5. 在一串字符串中查找某一个特殊的字符，这个特殊字符没有字符来表示它（比如过开始符:0x02 或结束符:0x03）
比如说需要在rx_buf中查找一个结符: memchr(rx_buf, '\x03', 32)

6. 求取一个16进制的数对应的十进制数的方法，比如说前端设备回复的一个16进制数 0x40 这个16进制数，存放在一个char型的数组中，
char buf[32] = {0};
int dataObiect;
buf[0] = 0x40;
unsigned char data; //当0x40为无符的16进制数的时候
data = (unsigned char)buf[0];
dataObiect = data;

signed char data;   //当0x40为有符号的10进制数的时候
data = (signed char)buf[0];
dataObiect = data;

7. 将一个16进制数，转化为对应的字符串，比如说将十六进制数0x20 转化位 字符串01
data[0] = 0x20;
sprintf(buf, "%02x", data[0]);







